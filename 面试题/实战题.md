# 实战题

## 问题 1

题目：

```JavaScript
var x = 10;
~(function (x) {
  console.log(x);
  x = x || 20 && 30 || 40;
  console.log(x);
})();
console.log(x);
```

结果

```JavaScript
undefined
30
10
```

**知识点**  
`a || b` : a 为真，返回 a，否则返回 b  
`a && b` : a 为真，返回 b，否则返回 a  
&& 的优先级高于 ||

所以 `x || 20 && 30 || 40` 这行代码先执行 `20 && 30` 因为 20 是真所以返回 30，然后从左向右执行，`x || (20 && 30)` 即 `x || 30`，因为 x 现在是`undefined`，所以返回 30，然后执行 `30 || 40` ，返回 30，所以此处 x 最终等于 30。

## 问题 2

题目：

```JavaScript
let x = [1, 2],
  y = [3, 4];
~(function (x) {
  x.push("A");
  x = x.slice(0);
  x.push("B");
  x = y;
  x.push("C");
  console.log(x, y);
})(x);
console.log(x, y);
```

结果

```JavaScript
[3,4,C] [3,4,C]
[1,2,A] [3,4,C]
```

**知识点**  
x.slice(0) ,slice 属于浅克隆，返回新数组，所以要新创建一个堆

## 问题 3

题目

```JavaScript
function Foo() {
  getName = function () { console.log (1); };
  return this;
}
Foo.getName = function () { console.log (2);};
Foo.prototype.getName = function () { console.log (3);};
var getName = function () { console.log (4);};
function getName() { console.log (5);}

Foo.getName();
getName();
Foo().getName();
getName();
new Foo.getName();
new Foo().getName();
new new Foo().getName();
```

结果

```JavaScript
2
4
1
1
2
3
3
```

### 解析
#### 第一问  
`Foo.getName()` 是对象Foo上的方法（或者说是类Foo的静态方法），即 `Foo.getName = function () { console.log (2);};` 这句声明的方法，此时输出 2。

#### 第二问
执行函数getName，由于是没有前缀的执行，即执行全局的 window.getName，此时寻找全局声明的getName，发现有
```JavaScript
var getName = function () { console.log (4);};
function getName() { console.log (5);}
```
由于函数的变量提示是整体提升，而var声明的变量提示是单纯的声明提升，定义还留在原地，所以此时相当于
```JavaScript
var getName;
function getName() { console.log (5);}
// ...
getName = function () { console.log (4);}
```
所以此时输出 4。

#### 第三问
函数调用和成员访问的优先级均为20，此时正常从左向右执行，即`(Foo()).getName()`，先执行`Foo()`，该函数执行的时候，给全局变量getName赋值`function () { console.log (1); }`，并返回了this，指向全局变量window，然后执行`window.getName()`，正好是Foo函数重新赋值的getName，所以此时输出 1。

#### 第四问
此时同第三问，还是在执行`window.getName()`，所以此时输出 1。

#### 第五问
由于new运算符的结构为new … ( … )，所以此时相当于`new (Foo.getName)()`，Foo.getName被视为构造函数，在new运算符执行的时候被执行一遍，所以此时输出 2。

#### 第六问
由于new运算符和成员访问的优先级均为20，所以此时相当于`(new Foo()).getName()`; 是类Foo的实例方法，此时调用Foo原型链上的getName方法，所以此时输出 3。

#### 第七问
`new new Foo().getName()`相当于`new ((new Foo()).getName)()`，所以此时输出 3。

## 参考文章
- [一道常被人轻视的前端JS面试题](https://www.cnblogs.com/xxcanghai/p/5189353.html)
- [运算符优先级](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
